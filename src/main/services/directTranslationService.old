// direct-translation-service.js - Version CORRIG√âE pour structure JSON valide
const fs = require('fs-extra')
const path = require('path')

class DirectTranslationService {
  constructor(customPath = null) {
    if (customPath) {
      this.translationsPath = customPath
    } else {
      const parentDir = path.join(require('os').homedir(), 'Documents')
      this.translationsPath = path.join(parentDir, 'tutoring-website', 'src', 'i18n', 'translations.js')
    }
  }

  setTranslationsPath(newPath) {
    this.translationsPath = newPath
    console.log('üìÅ Nouveau chemin traductions:', this.translationsPath)
  }

  /**
   * LECTURE AM√âLIOR√âE avec validation de structure
   */
  async getResourceTranslations(subject, resourceId) {
    try {
      console.log(`üîç Recherche traductions pour ${subject}/${resourceId}`)

      if (!await fs.pathExists(this.translationsPath)) {
        throw new Error(`Fichier translations.js introuvable: ${this.translationsPath}`)
      }

      // Lire et parser le fichier pour validation
      const content = await fs.readFile(this.translationsPath, 'utf8')

      // Essayer de valider la structure JS
      try {
        await this.validateTranslationStructure(content)
      } catch (error) {
        console.warn('‚ö†Ô∏è Structure potentiellement corrompue:', error.message)
        // Tenter une r√©paration automatique
        await this.repairTranslationFile()
      }

      // Pattern pour extraire les traductions
      const pattern = new RegExp(
        `${resourceId}:\\s*{\\s*` +
        `title:\\s*"([^"]*)",?\\s*` +
        `description:\\s*"([^"]*)",?\\s*` +
        `fullDescription:\\s*"([^"]*)",?\\s*` +
        `notes:\\s*"([^"]*)"\\s*` +
        `}`,
        'gs'
      )

      const matches = [...content.matchAll(pattern)]
      console.log(`üìä Trouv√© ${matches.length} occurrences de ${resourceId}`)

      const cleanValue = (str) => {
        if (!str || str === 'undefined') return ''
        return str.replace(/\\"/g, '"').replace(/\\n/g, '\n').trim()
      }

      const result = {
        fr: {
          title: matches[0] ? cleanValue(matches[0][1]) : '',
          description: matches[0] ? cleanValue(matches[0][2]) : '',
          fullDescription: matches[0] ? cleanValue(matches[0][3]) : '',
          notes: matches[0] ? cleanValue(matches[0][4]) : ''
        },
        en: {
          title: matches[1] ? cleanValue(matches[1][1]) : '',
          description: matches[1] ? cleanValue(matches[1][2]) : '',
          fullDescription: matches[1] ? cleanValue(matches[1][3]) : '',
          notes: matches[1] ? cleanValue(matches[1][4]) : ''
        }
      }

      return result
    } catch (error) {
      console.error('‚ùå Erreur lecture:', error.message)
      throw error
    }
  }

  /**
   * √âCRITURE ULTRA S√âCURIS√âE avec validation
   */
  async saveResourceTranslations(subject, resourceId, frTranslations, enTranslations) {
    try {
      console.log(`üíæ Sauvegarde traductions pour ${subject}/${resourceId}`)

      if (!await fs.pathExists(this.translationsPath)) {
        throw new Error(`Fichier translations.js introuvable: ${this.translationsPath}`)
      }

      // Cr√©er une sauvegarde
      const backupPath = this.translationsPath + '.backup.' + Date.now()
      await fs.copy(this.translationsPath, backupPath)
      console.log(`üíæ Sauvegarde cr√©√©e: ${backupPath}`)

      let content = await fs.readFile(this.translationsPath, 'utf8')

      // Valider la structure avant modification
      try {
        await this.validateTranslationStructure(content)
      } catch (error) {
        console.warn('‚ö†Ô∏è Structure corrompue d√©tect√©e, r√©paration...')
        content = await this.repairTranslationContent(content)
      }

      // Nettoyer les valeurs
      const clean = (str) => {
        if (!str) return ''
        return String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').trim()
      }

      // 1. Supprimer les anciennes occurrences de mani√®re S√âCURIS√âE
      content = this.removeResourceSafely(content, resourceId)

      // 2. Cr√©er les nouvelles entr√©es
      const frEntry = `          ${resourceId}: {
            title: "${clean(frTranslations.title)}",
            description: "${clean(frTranslations.description)}",
            fullDescription: "${clean(frTranslations.fullDescription)}",
            notes: "${clean(frTranslations.notes)}"
          }`

      const enEntry = `          ${resourceId}: {
            title: "${clean(enTranslations.title)}",
            description: "${clean(enTranslations.description)}",
            fullDescription: "${clean(enTranslations.fullDescription)}",
            notes: "${clean(enTranslations.notes)}"
          }`

      // 3. Ajouter les entr√©es de mani√®re S√âCURIS√âE
      content = this.insertResourceSafely(content, subject, frEntry, enEntry)

      // 4. Valider le r√©sultat final
      try {
        await this.validateTranslationStructure(content)
        console.log('‚úÖ Structure valid√©e apr√®s modification')
      } catch (error) {
        console.error('‚ùå Structure corrompue apr√®s modification:', error.message)
        throw new Error('Impossible de maintenir une structure valide')
      }

      // 5. Sauvegarder
      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('‚úÖ Fichier sauvegard√© avec succ√®s')

      // Supprimer la sauvegarde si tout s'est bien pass√©
      await fs.remove(backupPath)

      return true

    } catch (error) {
      console.error('‚ùå Erreur sauvegarde:', error.message)
      throw error
    }
  }

  /**
   * Supprime une ressource de mani√®re s√©curis√©e
   */
  removeResourceSafely(content, resourceId) {
    // Pattern plus s√©lectif pour √©viter de casser la structure
    const removePattern = new RegExp(
      `(\\s*,\\s*)?${resourceId}:\\s*{[^{}]*(?:{[^{}]*}[^{}]*)*}(\\s*,)?`,
      'g'
    )

    return content.replace(removePattern, (match, beforeComma, afterComma) => {
      // G√©rer intelligemment les virgules
      if (beforeComma && afterComma) {
        return ',' // Garder une virgule si l'√©l√©ment est au milieu
      } else if (beforeComma || afterComma) {
        return '' // Supprimer la virgule si l'√©l√©ment est au d√©but ou √† la fin
      }
      return ''
    })
  }

  /**
   * Ins√®re une ressource de mani√®re s√©curis√©e
   */
  insertResourceSafely(content, subject, frEntry, enEntry) {
    // Pattern pour trouver la fin de la section subject dans chaque langue
    const sectionPattern = new RegExp(
      `(${subject}:\\s*{)([^}]*(?:{[^{}]*}[^{}]*)*)(\\s*})`,
      'g'
    )

    let sectionCount = 0

    return content.replace(sectionPattern, (match, before, existing, after) => {
      sectionCount++

      const trimmedExisting = existing.trim()
      const needsComma = trimmedExisting && !trimmedExisting.endsWith(',')

      if (sectionCount === 1) {
        // Section fran√ßaise
        const newContent = needsComma ? existing + ',\n' + frEntry : existing + '\n' + frEntry
        return before + newContent + after
      } else if (sectionCount === 2) {
        // Section anglaise
        const newContent = needsComma ? existing + ',\n' + enEntry : existing + '\n' + enEntry
        return before + newContent + after
      }

      return match
    })
  }

  /**
   * Valide la structure du fichier translations
   */
  async validateTranslationStructure(content) {
    try {
      // Tenter d'√©valuer la structure JS de base
      const testContent = content
        .replace(/export\s+const\s+translations\s*=\s*/, 'const translations = ')
        .replace(/^\s*\/\/.*$/gm, '') // Supprimer les commentaires

      // Test simple de validation des accolades
      const openBraces = (testContent.match(/{/g) || []).length
      const closeBraces = (testContent.match(/}/g) || []).length

      if (openBraces !== closeBraces) {
        throw new Error(`Accolades non √©quilibr√©es: ${openBraces} ouvertures, ${closeBraces} fermetures`)
      }

      console.log('‚úÖ Structure de base valid√©e')
      return true
    } catch (error) {
      throw new Error(`Structure invalide: ${error.message}`)
    }
  }

  /**
   * R√©pare automatiquement le fichier de traductions
   */
  async repairTranslationFile() {
    console.log('üîß Tentative de r√©paration automatique...')

    try {
      let content = await fs.readFile(this.translationsPath, 'utf8')
      content = this.repairTranslationContent(content)

      // Cr√©er une sauvegarde avant r√©paration
      const repairBackup = this.translationsPath + '.before-repair.' + Date.now()
      await fs.copy(this.translationsPath, repairBackup)

      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('‚úÖ Fichier r√©par√© automatiquement')

      return true
    } catch (error) {
      console.error('‚ùå Impossible de r√©parer automatiquement:', error.message)
      throw error
    }
  }

  /**
   * R√©pare le contenu du fichier
   */
  repairTranslationContent(content) {
    // R√©parations de base
    content = content
      // Supprimer les virgules multiples
      .replace(/,(\s*,)+/g, ',')
      // Supprimer les virgules avant les accolades fermantes
      .replace(/,(\s*})/g, '$1')
      // Supprimer les virgules apr√®s les accolades ouvrantes
      .replace(/{\s*,/g, '{')
      // Nettoyer les espaces multiples
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      // Corriger les "undefined" en cha√Ænes vides
      .replace(/"undefined"/g, '""')

    return content
  }

  /**
   * Supprime les traductions d'une ressource
   */
  async removeResourceTranslations(subject, resourceId) {
    try {
      console.log(`üóëÔ∏è Suppression traductions pour ${subject}/${resourceId}`)

      let content = await fs.readFile(this.translationsPath, 'utf8')
      content = this.removeResourceSafely(content, resourceId)
      content = this.repairTranslationContent(content)

      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('‚úÖ Traductions supprim√©es')

      return true
    } catch (error) {
      console.error('‚ùå Erreur suppression:', error.message)
      throw error
    }
  }

  /**
   * Test complet du service avec validation
   */
  async test() {
    console.log('üß™ Test service de traductions s√©curis√©...')
    console.log('üìÅ Chemin:', this.translationsPath)

    try {
      const exists = await fs.pathExists(this.translationsPath)
      console.log('üìÑ Fichier existe:', exists)

      if (!exists) {
        console.error('‚ùå Fichier translations.js introuvable')
        return false
      }

      // Test de validation de structure
      console.log('\nüîç Validation de la structure...')
      const content = await fs.readFile(this.translationsPath, 'utf8')

      try {
        await this.validateTranslationStructure(content)
        console.log('‚úÖ Structure valide')
      } catch (error) {
        console.warn('‚ö†Ô∏è Structure invalide:', error.message)
        console.log('üîß Tentative de r√©paration...')
        await this.repairTranslationFile()
      }

      // Test de lecture
      console.log('\n1Ô∏è‚É£ Test lecture existante...')
      const existing = await this.getResourceTranslations('physics', 'test')
      console.log('   FR:', existing.fr.title)
      console.log('   EN:', existing.en.title)

      // Test d'ajout
      console.log('\n2Ô∏è‚É£ Test d\'ajout s√©curis√©...')
      const success = await this.saveResourceTranslations('maths', 'testSecurise',
        { title: 'Test S√©curis√© FR', description: 'Description FR', fullDescription: 'Complet FR', notes: 'Notes FR' },
        { title: 'Test Secure EN', description: 'Description EN', fullDescription: 'Complete EN', notes: 'Notes EN' }
      )

      if (success) {
        const added = await this.getResourceTranslations('maths', 'testSecurise')
        console.log('   Ajout√© FR:', added.fr.title)
        console.log('   Ajout√© EN:', added.en.title)

        // Validation finale
        const finalContent = await fs.readFile(this.translationsPath, 'utf8')
        await this.validateTranslationStructure(finalContent)
        console.log('‚úÖ Structure finale valid√©e')

        return true
      }

      return false

    } catch (error) {
      console.error('‚ùå Test √©chou√©:', error.message)
      return false
    }
  }
}

module.exports = DirectTranslationService

if (require.main === module) {
  const service = new DirectTranslationService()
  service.test().then(result => {
    console.log('\nüéØ R√©sultat du test:', result ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC')
    process.exit(result ? 0 : 1)
  }).catch(error => {
    console.error('üí• Erreur critique:', error)
    process.exit(1)
  })
}