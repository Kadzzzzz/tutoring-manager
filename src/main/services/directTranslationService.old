// direct-translation-service.js - Version CORRIGÃ‰E pour structure JSON valide
const fs = require('fs-extra')
const path = require('path')

class DirectTranslationService {
  constructor(customPath = null) {
    if (customPath) {
      this.translationsPath = customPath
    } else {
      const parentDir = path.join(require('os').homedir(), 'Documents')
      this.translationsPath = path.join(parentDir, 'tutoring-website', 'src', 'i18n', 'translations.js')
    }
  }

  setTranslationsPath(newPath) {
    this.translationsPath = newPath
    console.log('ðŸ“ Nouveau chemin traductions:', this.translationsPath)
  }

  /**
   * LECTURE AMÃ‰LIORÃ‰E avec validation de structure
   */
  async getResourceTranslations(subject, resourceId) {
    try {
      console.log(`ðŸ” Recherche traductions pour ${subject}/${resourceId}`)

      if (!await fs.pathExists(this.translationsPath)) {
        throw new Error(`Fichier translations.js introuvable: ${this.translationsPath}`)
      }

      // Lire et parser le fichier pour validation
      const content = await fs.readFile(this.translationsPath, 'utf8')

      // Essayer de valider la structure JS
      try {
        await this.validateTranslationStructure(content)
      } catch (error) {
        console.warn('âš ï¸ Structure potentiellement corrompue:', error.message)
        // Tenter une rÃ©paration automatique
        await this.repairTranslationFile()
      }

      // Pattern pour extraire les traductions
      const pattern = new RegExp(
        `${resourceId}:\\s*{\\s*` +
        `title:\\s*"([^"]*)",?\\s*` +
        `description:\\s*"([^"]*)",?\\s*` +
        `fullDescription:\\s*"([^"]*)",?\\s*` +
        `notes:\\s*"([^"]*)"\\s*` +
        `}`,
        'gs'
      )

      const matches = [...content.matchAll(pattern)]
      console.log(`ðŸ“Š TrouvÃ© ${matches.length} occurrences de ${resourceId}`)

      const cleanValue = (str) => {
        if (!str || str === 'undefined') return ''
        return str.replace(/\\"/g, '"').replace(/\\n/g, '\n').trim()
      }

      const result = {
        fr: {
          title: matches[0] ? cleanValue(matches[0][1]) : '',
          description: matches[0] ? cleanValue(matches[0][2]) : '',
          fullDescription: matches[0] ? cleanValue(matches[0][3]) : '',
          notes: matches[0] ? cleanValue(matches[0][4]) : ''
        },
        en: {
          title: matches[1] ? cleanValue(matches[1][1]) : '',
          description: matches[1] ? cleanValue(matches[1][2]) : '',
          fullDescription: matches[1] ? cleanValue(matches[1][3]) : '',
          notes: matches[1] ? cleanValue(matches[1][4]) : ''
        }
      }

      return result
    } catch (error) {
      console.error('âŒ Erreur lecture:', error.message)
      throw error
    }
  }

  /**
   * Ã‰CRITURE ULTRA SÃ‰CURISÃ‰E avec validation
   */
  async saveResourceTranslations(subject, resourceId, frTranslations, enTranslations) {
    try {
      console.log(`ðŸ’¾ Sauvegarde traductions pour ${subject}/${resourceId}`)

      if (!await fs.pathExists(this.translationsPath)) {
        throw new Error(`Fichier translations.js introuvable: ${this.translationsPath}`)
      }

      // CrÃ©er une sauvegarde
      const backupPath = this.translationsPath + '.backup.' + Date.now()
      await fs.copy(this.translationsPath, backupPath)
      console.log(`ðŸ’¾ Sauvegarde crÃ©Ã©e: ${backupPath}`)

      let content = await fs.readFile(this.translationsPath, 'utf8')

      // Valider la structure avant modification
      try {
        await this.validateTranslationStructure(content)
      } catch (error) {
        console.warn('âš ï¸ Structure corrompue dÃ©tectÃ©e, rÃ©paration...')
        content = await this.repairTranslationContent(content)
      }

      // Nettoyer les valeurs
      const clean = (str) => {
        if (!str) return ''
        return String(str).replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').trim()
      }

      // 1. Supprimer les anciennes occurrences de maniÃ¨re SÃ‰CURISÃ‰E
      content = this.removeResourceSafely(content, resourceId)

      // 2. CrÃ©er les nouvelles entrÃ©es
      const frEntry = `          ${resourceId}: {
            title: "${clean(frTranslations.title)}",
            description: "${clean(frTranslations.description)}",
            fullDescription: "${clean(frTranslations.fullDescription)}",
            notes: "${clean(frTranslations.notes)}"
          }`

      const enEntry = `          ${resourceId}: {
            title: "${clean(enTranslations.title)}",
            description: "${clean(enTranslations.description)}",
            fullDescription: "${clean(enTranslations.fullDescription)}",
            notes: "${clean(enTranslations.notes)}"
          }`

      // 3. Ajouter les entrÃ©es de maniÃ¨re SÃ‰CURISÃ‰E
      content = this.insertResourceSafely(content, subject, frEntry, enEntry)

      // 4. Valider le rÃ©sultat final
      try {
        await this.validateTranslationStructure(content)
        console.log('âœ… Structure validÃ©e aprÃ¨s modification')
      } catch (error) {
        console.error('âŒ Structure corrompue aprÃ¨s modification:', error.message)
        throw new Error('Impossible de maintenir une structure valide')
      }

      // 5. Sauvegarder
      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('âœ… Fichier sauvegardÃ© avec succÃ¨s')

      // Supprimer la sauvegarde si tout s'est bien passÃ©
      await fs.remove(backupPath)

      return true

    } catch (error) {
      console.error('âŒ Erreur sauvegarde:', error.message)
      throw error
    }
  }

  /**
   * Supprime une ressource de maniÃ¨re sÃ©curisÃ©e
   */
  removeResourceSafely(content, resourceId) {
    // Pattern plus sÃ©lectif pour Ã©viter de casser la structure
    const removePattern = new RegExp(
      `(\\s*,\\s*)?${resourceId}:\\s*{[^{}]*(?:{[^{}]*}[^{}]*)*}(\\s*,)?`,
      'g'
    )

    return content.replace(removePattern, (match, beforeComma, afterComma) => {
      // GÃ©rer intelligemment les virgules
      if (beforeComma && afterComma) {
        return ',' // Garder une virgule si l'Ã©lÃ©ment est au milieu
      } else if (beforeComma || afterComma) {
        return '' // Supprimer la virgule si l'Ã©lÃ©ment est au dÃ©but ou Ã  la fin
      }
      return ''
    })
  }

  /**
   * InsÃ¨re une ressource de maniÃ¨re sÃ©curisÃ©e
   */
  insertResourceSafely(content, subject, frEntry, enEntry) {
    // Pattern pour trouver la fin de la section subject dans chaque langue
    const sectionPattern = new RegExp(
      `(${subject}:\\s*{)([^}]*(?:{[^{}]*}[^{}]*)*)(\\s*})`,
      'g'
    )

    let sectionCount = 0

    return content.replace(sectionPattern, (match, before, existing, after) => {
      sectionCount++

      const trimmedExisting = existing.trim()
      const needsComma = trimmedExisting && !trimmedExisting.endsWith(',')

      if (sectionCount === 1) {
        // Section franÃ§aise
        const newContent = needsComma ? existing + ',\n' + frEntry : existing + '\n' + frEntry
        return before + newContent + after
      } else if (sectionCount === 2) {
        // Section anglaise
        const newContent = needsComma ? existing + ',\n' + enEntry : existing + '\n' + enEntry
        return before + newContent + after
      }

      return match
    })
  }

  /**
   * Valide la structure du fichier translations
   */
  async validateTranslationStructure(content) {
    try {
      // Tenter d'Ã©valuer la structure JS de base
      const testContent = content
        .replace(/export\s+const\s+translations\s*=\s*/, 'const translations = ')
        .replace(/^\s*\/\/.*$/gm, '') // Supprimer les commentaires

      // Test simple de validation des accolades
      const openBraces = (testContent.match(/{/g) || []).length
      const closeBraces = (testContent.match(/}/g) || []).length

      if (openBraces !== closeBraces) {
        throw new Error(`Accolades non Ã©quilibrÃ©es: ${openBraces} ouvertures, ${closeBraces} fermetures`)
      }

      console.log('âœ… Structure de base validÃ©e')
      return true
    } catch (error) {
      throw new Error(`Structure invalide: ${error.message}`)
    }
  }

  /**
   * RÃ©pare automatiquement le fichier de traductions
   */
  async repairTranslationFile() {
    console.log('ðŸ”§ Tentative de rÃ©paration automatique...')

    try {
      let content = await fs.readFile(this.translationsPath, 'utf8')
      content = this.repairTranslationContent(content)

      // CrÃ©er une sauvegarde avant rÃ©paration
      const repairBackup = this.translationsPath + '.before-repair.' + Date.now()
      await fs.copy(this.translationsPath, repairBackup)

      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('âœ… Fichier rÃ©parÃ© automatiquement')

      return true
    } catch (error) {
      console.error('âŒ Impossible de rÃ©parer automatiquement:', error.message)
      throw error
    }
  }

  /**
   * RÃ©pare le contenu du fichier
   */
  repairTranslationContent(content) {
    // RÃ©parations de base
    content = content
      // Supprimer les virgules multiples
      .replace(/,(\s*,)+/g, ',')
      // Supprimer les virgules avant les accolades fermantes
      .replace(/,(\s*})/g, '$1')
      // Supprimer les virgules aprÃ¨s les accolades ouvrantes
      .replace(/{\s*,/g, '{')
      // Nettoyer les espaces multiples
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      // Corriger les "undefined" en chaÃ®nes vides
      .replace(/"undefined"/g, '""')

    return content
  }

  /**
   * Supprime les traductions d'une ressource
   */
  async removeResourceTranslations(subject, resourceId) {
    try {
      console.log(`ðŸ—‘ï¸ Suppression traductions pour ${subject}/${resourceId}`)

      let content = await fs.readFile(this.translationsPath, 'utf8')
      content = this.removeResourceSafely(content, resourceId)
      content = this.repairTranslationContent(content)

      await fs.writeFile(this.translationsPath, content, 'utf8')
      console.log('âœ… Traductions supprimÃ©es')

      return true
    } catch (error) {
      console.error('âŒ Erreur suppression:', error.message)
      throw error
    }
  }

  /**
   * Test complet du service avec validation
   */
  async test() {
    console.log('ðŸ§ª Test service de traductions sÃ©curisÃ©...')
    console.log('ðŸ“ Chemin:', this.translationsPath)

    try {
      const exists = await fs.pathExists(this.translationsPath)
      console.log('ðŸ“„ Fichier existe:', exists)

      if (!exists) {
        console.error('âŒ Fichier translations.js introuvable')
        return false
      }

      // Test de validation de structure
      console.log('\nðŸ” Validation de la structure...')
      const content = await fs.readFile(this.translationsPath, 'utf8')

      try {
        await this.validateTranslationStructure(content)
        console.log('âœ… Structure valide')
      } catch (error) {
        console.warn('âš ï¸ Structure invalide:', error.message)
        console.log('ðŸ”§ Tentative de rÃ©paration...')
        await this.repairTranslationFile()
      }

      // Test de lecture
      console.log('\n1ï¸âƒ£ Test lecture existante...')
      const existing = await this.getResourceTranslations('physics', 'test')
      console.log('   FR:', existing.fr.title)
      console.log('   EN:', existing.en.title)

      // Test d'ajout
      console.log('\n2ï¸âƒ£ Test d\'ajout sÃ©curisÃ©...')
      const success = await this.saveResourceTranslations('maths', 'testSecurise',
        { title: 'Test SÃ©curisÃ© FR', description: 'Description FR', fullDescription: 'Complet FR', notes: 'Notes FR' },
        { title: 'Test Secure EN', description: 'Description EN', fullDescription: 'Complete EN', notes: 'Notes EN' }
      )

      if (success) {
        const added = await this.getResourceTranslations('maths', 'testSecurise')
        console.log('   AjoutÃ© FR:', added.fr.title)
        console.log('   AjoutÃ© EN:', added.en.title)

        // Validation finale
        const finalContent = await fs.readFile(this.translationsPath, 'utf8')
        await this.validateTranslationStructure(finalContent)
        console.log('âœ… Structure finale validÃ©e')

        return true
      }

      return false

    } catch (error) {
      console.error('âŒ Test Ã©chouÃ©:', error.message)
      return false
    }
  }
}

module.exports = DirectTranslationService

if (require.main === module) {
  const service = new DirectTranslationService()
  service.test().then(result => {
    console.log('\nðŸŽ¯ RÃ©sultat du test:', result ? 'âœ… SUCCÃˆS' : 'âŒ Ã‰CHEC')
    process.exit(result ? 0 : 1)
  }).catch(error => {
    console.error('ðŸ’¥ Erreur critique:', error)
    process.exit(1)
  })
}